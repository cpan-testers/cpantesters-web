#!perl
use Mojolicious::Lite;
use Mojolicious::Validator;
use Set::Tiny 0.04;
use Data::FlexSerializer 1.10;
use DBI 1.636;
use Try::Tiny 0.27;
use JSON 2.90;
use Metabase::Resource 0.025;
use CPAN::Testers::Report 1.999003;
use Metabase::Resource::cpan::distfile 0.025;
use Metabase::Resource::metabase::user;
use Carp;

=head1 NAME

cpantesters-web-legacy -- Start the CPAN Testers Legacy web application

=head1 SYNOPSIS

  cpantesters-web-legacy daemon
  cpantesters-web-legacy help

=head1 DESCRIPTION

This program loads the CPAN Testers Legacy web application,
a L<Mojolicious> web application. For more detailed help, see
C<cpantesters-web-legacy help>.

=head1 SEE ALSO

L<CPAN::Testers::Web>, L<Mojolicious>

=cut

my $dsn  = "DBI:mysql:database=metabase;host=127.0.0.1;port=30306";
my $user = 'cpantesters';
my $pass = '';

get '/report/:guid' => sub {
    my $c    = shift;
    my $guid = $c->stash('guid');
    my $dbh  = get_dbh( $dsn, $user, $pass );

    # hash ref
    my $params_ref = $c->req->query_params->to_hash;
    $c->app->log->debug( 'GET parameters: ' . params_to_string($params_ref) );
    my @names = keys( %{$params_ref} );

    if ( scalar(@names) == 1 ) {

        my $validator  = Mojolicious::Validator->new;
        my $validation = $validator->validation;
        $validation->input( { $names[0] => $params_ref->{ $names[0] } } );
        $validation->required( $names[0] )->like(qr/^0|1$/);
        my $val_result = $validation->param( $names[0] );
        $c->app->log->debug($val_result);
        my $valid_params = Set::Tiny->new(qw(json raw));

        if (    $valid_params->has( $names[0] )
            and ( defined($val_result) )
            and ( $validation->param( $names[0] ) == 1 ) )
        {
            $c->render(
                text => "Getting report for GUID=$guid with $names[0]" );
        }
        else {
            $c->app->log->debug("Ignoring parameter $names[0]");
            $c->render( text => "Getting report for GUID=$guid" );
        }
    }
    else {

        if ( scalar(@names) == 0 ) {
            $c->app->log->debug('No parameters received');
        }
        else {
            $c->app->log->debug('Ignoring multiple parameters');
        }

        my $report;

        try {
            $report = get_report( $dbh, $guid );
        }
        catch {
            $c->app->log->fatal(
                "A fatal error occurred when processing $guid: $_");
            die "Could not process your request, contact the administrator";
        };

        $c->redirect_to('/missing') unless ( defined($report) );
        use Data::Dumper;
        $c->render( text => Dumper($report) );
    }

    $dbh->disconnect;
};

# Not found (404)
get '/missing' => sub { shift->render( template => 'does_not_exist' ) };

sub params_to_string {
    my $params_ref = shift;
    my @text;

    foreach my $name ( keys( %{$params_ref} ) ) {
        push( @text, $name . ' = ' . $params_ref->{$name} );
    }

    return join( "\n", @text );
}

sub get_dbh {
    my ( $data_source, $username, $auth ) = @_;
    return DBI->connect( $data_source, $username, $auth,
        { RaiseError => 1, AutoCommit => 0, 'mysql_enable_utf8' => 1 } );
}

sub get_report {
    my ( $dbh, $guid, $logger ) = @_;
    my $query = q{select fact, report from metabase.metabase where guid = ?};
    my $sth   = $dbh->prepare($query);
    $sth->bind_param( 1, $guid );
    $sth->execute();
    my $row_ref = $sth->fetchrow_arrayref;

# :TODO:08/05/2017 19:26:47:ARFREITAS: $data is intermediate data, it can be moved to upper to other subs and maintained in
# memory for a shorter period of time
    my ( $report, $data, $error );

    if ( scalar( @{$row_ref} ) > 0 ) {

        # has the fact
        if ( defined( $row_ref->[0] ) ) {
            $report = get_serial_data( $row_ref, 0 );
            $data = dereference_report($report);
        }
        else {
            $data = get_serial_data( $row_ref, 1 );
            $report = {
                metadata => {
                    core => { guid => $guid, type => 'CPAN-Testers-Report' }
                }
            };

            foreach my $name ( keys( %{$data} ) ) {
                push @{ $report->{content} }, $data->{$name};
            }

        }

        my $fact;

        if (
            ref( $data->{'CPAN::Testers::Fact::LegacyReport'}->{content} ) eq
            'HASH' )
        {
            $fact = gen_fact( $data, 'CPAN::Testers::Fact::LegacyReport' );
        }
        elsif (
            ref( $data->{'CPAN::Testers::Fact::TestSummary'}->{content} ) eq
            'HASH' )
        {
            $fact = gen_fact( $data, 'CPAN::Testers::Fact::TestSummary' );
        }
        else {
            die
'Cannot process data, neither CPAN::Testers::Fact::LegacyReport or CPAN::Testers::Fact::TestSummary';
        }

       # :TODO:08/05/2017 21:40:25:ARFREITAS: use a better name instead of tvars
        my %tvars;
        $tvars{article}->{article} = $fact->{content}->{textreport};
        $tvars{article}->{guid}    = $guid;

# :TODO:08/05/2017 20:46:19:ARFREITAS: this seems to be ilogical... if
# $fact is not recovered from the database, it will be created based on $data anyway
# it should be same same thing using one or another
        if ( defined( $row_ref->[0] ) ) {
            map_attribs( $report, $fact );
        }
        else {
            map_attribs( $report, $data );
        }

        $tvars{article}->{state}    = lc( $fact->{content}->{grade} );
        $tvars{article}->{platform} = $fact->{content}->{archname};
        $tvars{article}->{osname}  = query_osname( $fact->{content}->{osname} );
        $tvars{article}->{osvers}  = $fact->{content}->{osversion};
        $tvars{article}->{perl}    = $fact->{content}->{perl_version};
        $tvars{article}->{created} = $fact->{metadata}->{core}->{creation_time};
        my $dist =
          Metabase::Resource->new( $fact->{metadata}->{core}->{resource} );
        $tvars{article}->{dist}    = $dist->metadata->{dist_name};
        $tvars{article}->{version} = $dist->metadata->{dist_version};
        ( $tvars{article}->{author}, $tvars{article}->{from} ) =
          get_tester( $dbh, $fact->creator );
        $tvars{article}->{author} =~ s/\@/ [at] /g;
        $tvars{article}->{from} =~ s/\@/ [at] /g;
        $tvars{article}->{from} =~ s/\./ [dot] /g;

        if ( $tvars{article}{created} ) {
            my @created = $tvars{article}->{created} =~
              /(\d+)-(\d+)-(\d+)T(\d+):(\d+):(\d+)Z/;    # 2010-02-23T20:33:52Z
            $tvars{article}->{postdate} = sprintf "%04d%02d", $created[0],
              $created[1];
            $tvars{article}->{fulldate} = sprintf "%04d%02d%02d%02d%02d",
              $created[0], $created[1], $created[2], $created[3], $created[4];
        }
        else {
            my @created = localtime(time);
            $tvars{article}->{postdate} = sprintf "%04d%02d",
              $created[5] + 1900,
              $created[4] + 1;
            $tvars{article}->{fulldate} = sprintf "%04d%02d%02d%02d%02d",
              $created[5] + 1900, $created[4] + 1, $created[3], $created[2],
              $created[1];
        }

        $tvars{article}->{letter} = substr( $tvars{article}->{dist}, 0, 1 );
        $tvars{article}->{subject} = sprintf "%s %s-%s %s %s",
          uc( $tvars{article}->{state} ), $tvars{article}->{dist},
          $tvars{article}->{version}, $tvars{article}->{perl},
          $tvars{article}->{osname};
        $tvars{body}->{result} = decode_report($report);

# :TODO:08/05/2017 21:40:56:ARFREITAS: returning a hash reference would be better
        return \%tvars;
    }
    else {
        return undef;
    }

}

sub get_tester {
    my ( $dbh, $creator ) = @_;
    my $query = q{SELECT mte.fullname, tp.name, tp.pause, tp.contact, mte.email
FROM metabase.testers_email mte 
LEFT JOIN testers.address ta ON ta.email=mte.email 
LEFT JOIN testers.profile tp ON tp.testerid=ta.testerid 
WHERE mte.resource=?
ORDER BY tp.testerid DESC
limit 1};
    my $sth = $dbh->prepare($query);
    $sth->bind_param( 1, $creator );
    $sth->execute();
    my $row_ref = $sth->fetchrow_arrayref;
    unless ( scalar( @{$row_ref} ) > 0 ) {
        return $creator, $creator;
    }
    else {
        my $name = $row_ref->[0];
        $name = join( ' ', $row_ref->[1], $row_ref->[2] )
          if ( defined( $row_ref->[1] ) );
        my $email = $row_ref->[3] || $row_ref->[4] || $creator;
        $email =~ s/\'/''/g if ($email);
        return $name, $email;
    }

}

# :TODO:08/05/2017 21:04:10:ARFREITAS: this can be easily cached from the DB
sub query_osname {
    my ( $dbh, $os_name ) = @_;
    return 'UNKNOWN' unless ($os_name);
    my $query = q{SELECT ostitle FROM cpanstats.osname where osname = ?};
    my $sth   = $dbh->prepare($query);
    my $code  = lc($os_name);
    $code =~ s/[^\w]+//g;
    $sth->bind_param( 1, $code );
    $sth->execute();
    my $preferred_name = $sth->fetchrow_arrayref()->[0];

    if ( defined($preferred_name) ) {
        return $preferred_name;
    }
    else {
        return uc($os_name);
    }
}

# changes report in place
sub map_attribs {
    my ( $report, $source ) = @_;
    my @attribs =
      qw(resource schema_version creation_time valid creator update_time);
    my $source_path;

    if ( $source->isa('CPAN::Testers::Fact::LegacyReport') ) {
        $source_path = $source->{metadata}->{core};
    }
    else {
        $source_path =
          $source->{'CPAN::Testers::Fact::TestSummary'}->{metadata}->{core};
    }

    foreach my $attrib (@attribs) {
        $report->{metadata}->{core}->{$attrib} = $source_path->{$attrib};
    }
}

sub gen_fact {
    my ( $data_ref, $fact_name ) = @_;

    try {
        $data_ref->{$fact_name}->{content} =
          encode_json( $data_ref->{$fact_name}->{content} );
        return CPAN::Testers::Fact::TestSummary->from_struct(
            $data_ref->{$fact_name} );
    }
    catch {
        die "Failed to encode $fact_name as JSON: $_";
    }

}

sub decode_report {
    my $report = shift;
    my $hash;

    # do we have an encoded report object?
    if ( ref($report) eq 'CPAN::Testers::Report' ) {
        $hash = $report->as_struct;
        $hash->{content} = decode_json( $hash->{content} );

        foreach my $content ( @{ $hash->{content} } ) {
            $content->{content} = decode_json( $content->{content} );
        }

        return encode_json($hash);
    }

    try {

        # we have a manufactured hash, with a collection of fact objects
        foreach my $fact ( @{ $report->{content} } ) {
            $fact->{content} = decode_json( $fact->{content} );
        }

        return encode_json($report);
    }
    catch {
        confess $_;
    };

    my @facts = $report->facts();

    foreach my $fact (@facts) {
        my $name = ref($fact);
        $hash->{'CPAN::Testers::Report'}->{content}{$name} = $fact->as_struct();
    }

    return $hash;
}

sub dereference_report {
    my ($report) = @_;
    my %facts;
    my @facts = $report->facts();

    foreach my $fact (@facts) {
        my $name = ref($fact);
        $facts{$name} = $fact->as_struct;
        $facts{$name}{content} = decode_json( $facts{$name}{content} );
    }

    return \%facts;
}

sub get_serial_data {

    # to use the array reference instead of copying all the data
    my ( $data_ref, $index ) = @_;
    my $serializer = Data::FlexSerializer->new(
        detect_compression => 1,
        detect_sereal      => 1,
        detect_json        => 1,
    );
    return $serializer->deserialize( $data_ref->[$index] );
}

app->start;

# vim: filetype=perl
